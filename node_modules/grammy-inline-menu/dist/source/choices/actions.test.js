"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const ava_1 = require("ava");
const actions_1 = require("./actions");
(0, ava_1.default)('choices are not called when hide is true', async (t) => {
    const func = (0, actions_1.combineHideAndChoices)('bla', () => {
        throw new Error('dont call choices when already hidden');
    }, () => true);
    const isHidden = await func(undefined, '/');
    t.is(isHidden, true);
});
(0, ava_1.default)('does not hide when choice still available', async (t) => {
    const func = (0, actions_1.combineHideAndChoices)('bla', ['a'], undefined);
    const path = '/foo/bar/bla:a';
    const isHidden = await func(undefined, path);
    t.is(isHidden, false);
});
(0, ava_1.default)('does not hide when choice still available from function', async (t) => {
    const func = (0, actions_1.combineHideAndChoices)('bla', () => ['a'], undefined);
    const path = '/foo/bar/bla:a';
    const isHidden = await func(undefined, path);
    t.is(isHidden, false);
});
(0, ava_1.default)('hides when choice isnt available anymore', async (t) => {
    const func = (0, actions_1.combineHideAndChoices)('bla', ['a'], undefined);
    const path = '/foo/bar/bla:wow';
    const isHidden = await func(undefined, path);
    t.is(isHidden, true);
});
(0, ava_1.default)('does not hide submenu when choice still available from function', async (t) => {
    const func = (0, actions_1.combineHideAndChoices)('bla', () => ['a'], undefined);
    const path = '/foo/bar/bla:a/';
    const isHidden = await func(undefined, path);
    t.is(isHidden, false);
});
(0, ava_1.default)('unrelated path throws', async (t) => {
    const func = (0, actions_1.combineHideAndChoices)('bla', () => ['a'], undefined);
    await t.throwsAsync(async () => func(undefined, 'hi there'), {
        message: 'could not read choice from path',
    });
});
//# sourceMappingURL=actions.test.js.map